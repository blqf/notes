# 渲染原理

## 术语
- React元素：通过React.createElement创建的元素，包括书写的JSX代码，也是React元素
- React节点：用于渲染到UI界面的对象，React节点可以由React元素创建（但也不一定），也就是说，想要将一个React元素渲染到页面上，React元素首先要创建相应的React节点（在JSX中可以写的，都可以创建React节点）
  - 节点类型 ：
    - React DOM节点：创建该节点的React元素是React自带的React元素，例如：<div></div>、<span></span>
    - React 组件节点：创建该节点的React元素类型是一个函数或类，例如：<App />
    - React 文本节点：通过字符串，数字创建的，这个也是一个节点对象
    - React 空节点：通过null、undefined、boolean创建，这个也是一个节点对象
    - React 数组节点：该节点通过数组创建
- 真实DOM对象：通过document.createElement创建的对象

渲染过程：React元素 -> React节点 -> 真实DOM

## 首次渲染（新节点渲染）
1. React根据```React.createElement(<App />)```中参数的值创建对应的React节点
2. 根据生成节点的不同，React会做不同的事情
  1. React 文本节点：直接通过document.createTextNode创建真实的文本节点**这里创建了真实DOM**
  2. React 空节点：什么都不做
  3. React 数组节点：遍历数组，将数组的每一项递归创建节点，回到**第1步**重复操作，直到遍历结束
  4. React DOM节点：通过document.createElement创建真实的DOM对象**这里创建了真实的DOM**，该真实的DOM对象会附着在React节点上，然后立即设置真实DOM的各种属性，然后深度遍历对应React元素的children属性，回到**第1步**，直到遍历结束
  5. React 组件节点
    1. 函数组件：该函数必须返回一个可以生成节点的内容，调用该函数，将函数的返回结果递归生成节点，回到**第1步**
    2. 类组件：
      1. 创建该类的实例，并将实例附着在节点上
      2. 立即调用对象的生命周期方法 static getDerivedStateFromProps
      3. 运行render方法，将返回的React元素生成对应的节点对象，递归操作子节点，回到**第1步**
      4. 将该组件的componentDidMount生命周期加入队列等待执行（挂载完以后再执行，所以在这里是可以获取真实的DOM元素的）
3. 此时，我们已经生成了一个**虚拟DOM树**，每一个DOM节点上会附着一个真实节点，每一个类组件节点上会附着一个组件实例，函数组件节点上什么都不会附着
4. 将附着在节点上的真实DOM对象，按照虚拟DOM树的结构，加入到**容器中？**（生成对应的真实DOM树）
***生成的虚拟DOM树会被保存起来，以便后续使用***

## 更新渲染
### 什么时候会更新节点？
1. 重新调用ReactDOM.render，会从根节点开始，完全重新生成一个虚拟DOM树
2. 改变状态，在类组件中调用setState，会从当前组件的根节点向下更新**这也是单向数据流的优点之一**

### 触发更新的两种情况
- 如果调用的是ReactDOM.render，进入根节点进行对比(diff)更新
- 如果调用的是setState
  1. 调用static getDerivedStateFromProps
  2. 运行生命周期函数shouldComponentUpdate，如果该函数返回false，终止当前流程
  3. 运行render生成一个新的节点，对新的节点进行对比更新
  4. 将getSnapshotBeforeUpdate函数加入队列，等待执行
  5. 将componentDidUpdate函数加入队列，等待执行
- 最后的后续步骤
1. 更新虚拟DOM树
2. 完成真实的DOM更新(**从这里开始，两种更新通用**)
3. 调用执行队列中的componentDidMount（如果需要）
4. 调用执行队列中的getSnapshotBeforeUpdate
5. 调用执行队列中的componentDidUpdate

（diff算法）
### React对比更新做出的假设
将产生的新节点，与之前保存的虚拟DOM进行对比，发现差异后，进行更新
*此时，我们遇到一个问题，新树要与旧树的哪个接节点进行对比？*
我们可以为每一个节点添加一个唯一标识，但是，这样会出现效率问题
为了提高对比的效率，React做出了一下假设：
1. 节点不会出现层级的移动，这样只需要直接到对应的层级去寻找应该对比的节点
2. 不同的节点类型，会生成不同的结构的虚拟DOM树
3. 多个兄弟节点通过唯一标识key来确定对比的节点

### 如何判断节点类型相同？
1. 节点本身的类型相同
2. 如果是组件节点，组件类型也必须相同（必须是同一个组件）
3. 如果有key值，key值也必须一样才行（没有key的话就算了，只看前两条）

### 假如新节点找到了对比的目标
#### 判断节点类型是否一致
**一致的话，根据不同的节点做不同的事**
1. 空节点：不做任何事
2. React DOM节点：重用之前的真实DOM，只是将其属性的变化记录下来，以待将来统一进行更新，遍历该节点的点，递归对比更新
3. 文本节点，直接重用该对象，记录变化的nodeValue值
4. 组件节点：
  1. 函数组件：直接重新调用函数，得到一个新的节点对象，进行递归对比
  2. 类组件：
    1. 重用之前的实例
    2. 按照上面“如果调用的是setState”所述的过程进行执行
5. 数组节点：遍历数组，遍历数组，递归对比更新

**不一致的话，整体卸载旧节点，全新创建新的节点**
1. 创建新节点，后续步骤同**新节点渲染**一样
2. 如果旧节点是文本节点、DOM节点、数组节点、空节点、函数组价节点
  1. 就直接放弃旧节点
  2. 如果有子节点，递归卸载子节点
3. 如果旧节点是类组件节点
  1. 直接放弃该节点
  2. 调用该节点的componentWillUnmount函数
  3. 递归卸载子节点(**这里子节点的状态会丢失，重置，所以尽量不要改变组件的节点结构**)
***卸载节点的时候，会丢失节点的状态***

那我们什么时候需要给节点添加key呢？
答：多个同级节点结构相同的时候。这样主要是为了防止节点在寻找对比目标的时候，找不到自己原来对应的是哪一个旧节点。