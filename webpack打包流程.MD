# wepback.config.js之所以要用module.exports(commonJS)方式导出，
# 而不可以用export defult(ES6)方式导出，
# 是因为webpack.config.js里的代码在编译过程中时要参与运行的，
# 而编译的过程是在node环境下进行的，所以必须用CommonJS方式导出

# webpack编译过程
1. 初始化.
  webpack将cli参数。配置文件。默认配置进行融合，形成一个终极配置对象
  融合的过程是靠带三方库yargs完成的。

2. 编译。
  * 创建chunk(通过某个入口找到所有依赖的统称,可以理解成一条链子节点的集合,而一个入口就是一个chunk)

  * 构建所有的依赖模块(这一过程的目的就是生成依赖模块列表)
  Ⅰ. 检查模块记录->
  Ⅱ. 读取未记录文件的内容,并对其进行抽象语法树分析(目的是找到这个文件的依赖)->
  Ⅲ. 将Ⅱ分析到的文件依赖保存到dependencies(一个里面是字符串的数组,数组内容为模块的唯一路径)->
  Ⅳ. 转换代码(将文件里的依赖路径替换成dependencies中的唯一路径)->
  Ⅴ. 将转换后的代码保存到模块记录里面(就是刚开始用的那个模块记录,模式为一个id(路径)对应一段转换后的代码)->
  Ⅵ. 看dependencies中有没有其他依赖,有的话就回到Ⅰ进行递归.
  完事后: 将各个chunk连接起来生成一个总的资源清单(大链子)
  (小插曲: 最终会在chunk中形成多个模块,就是链子的每个节点)

  * webpack为chunk形成资源列表(可以理解为将链子的节点连接起来),就是最终编译文件里的{ "路径": function(module){} },路径与函数内容都来自模块记录.
  hash: 总的资源清单的hash值(大链子)
  chunkhash: 各个chunk的hash值(单个链子)
  chunkname: 各个chunk的名字

3. 输出。
  webpack利用node中的fs模块(文件处理模块),根据编译产生的assets(资源列表),生成相应的文件(将各个链子合并成一个大链子)



webpack根据入口形成很多chunk,进而分析各个chunk所依赖的模块,最终形成资源列表,然后打包到指定的文件中

loader的本质是一个“函数”,传入源代码,返回处理后的代码
plugin的本质是一个带有apply方法的“对象”